\documentclass{article}

\usepackage[french, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{mdframed}
\usepackage{xcolor}

%% Better maths
\usepackage{amsmath, amssymb, amsthm, xfrac, semantic}

%% Code listings
\usepackage{listings}
\lstset{language=[Objective]Caml, captionpos=b, frame=single}

\usepackage{multicol}

% % Annexes
\usepackage{appendix}

%% Hack for minus signs in listings....
\mathchardef\hyphenmathcode=\mathcode`\-
\let\origlstlisting=\lstlisting
\let\endoriglstlisting=\endlstlisting
\renewenvironment{lstlisting}
{\mathcode`\-=\hyphenmathcode
    \everymath{}\mathsurround=0pt\origlstlisting}
{\endoriglstlisting}

%% Déclaration des fonctions mathématiques
\DeclareMathOperator{\iT}{T}
\DeclareMathOperator{\iH}{H}
\DeclareMathOperator{\iTI}{TI}
\DeclareMathOperator{\iDom}{dom}
\DeclareMathOperator{\iLambda}{\lambda}
\DeclareMathOperator{\ienvSPlit}{envSplitsN}
\DeclareMathOperator{\isplit}{splitsN}

%% Environnements maths (amsthm)
\newtheorem{Def}{Definition}
\newtheorem{Ex}{Example}
\newtheorem*{Ex*}{Example}
\newtheorem*{Th*}{Theorem}
\newtheorem*{Lem*}{Lemma}

\def\lcalc{$\lambda$-calculus}
\def\lci{$\lambda$-calculi}
\def\lterm{$\lambda$-term}
\def\lterms{$\lambda$-terms}
\def\aconv{$\alpha$-conversion}
\def\sysm{system $\mathcal{M}$}
\def\ver{\ |\ }

\newcommand{\sslash}{\mathbin{/\mkern-6mu/}}


\title{\textbf{Inhabitation Problem in lambda calculus with non-idempotent intersection types}}
\author{Ulysse Gérard}
\date\today

\begin{document}

\maketitle

\section{Introduction}
The operation of typing is well known in \lcalc. And numerous typing systems have been imagined to give a signification to \lterms, attributing types to them. But the opposite problem exists, when we want to decide, given a type $A$ and a typing environment $\Gamma$, whether or not there exists a term $t$ such that $\Gamma \vdash t : A$ is provable. This problem is called the \emph{inhabitation problem}.
\begin{figure}
    \begin{mdframed}
        \begin{gather*}
        \inference[]{}{\Gamma, x:A\vdash x:A}
        \qquad \inference[]{\Gamma, x:A \vdash t:B}{\Gamma \vdash \lambda x.t:A->B}
        \\ \\ \inference[]{\Gamma \vdash t : A -> B & \Gamma \vdash u : A} {\Gamma \vdash tu : B}
        \\ \\ \text{For types } A, B ::= \tau\ver A \rightarrow B
        \end{gather*}
    \end{mdframed}
    \caption{Simple types}
    \label{STY}
\end{figure}


The inhabitation problem has been studied for numerous type systems. For example, simply typed \lcalc (Fig. \ref{STY}), a type system \emph{without intersection types} has a decidable inhabitation problem. However, these types do not characterize \emph{strongly-normalizing terms}: simply typed terms are strongly-normalizing, but there exists strongly-normalizing terms which are not simply-typable ($\lambda x.xx$). That is why \emph{intersection types} have been introduced.

This being, types systems with \emph{idempotent intersection types} take a step toward abstraction and become undecidable. They are no more suitable to describe programming languages, but can be useful tools to understand \lcalc. For example, the system $\mathcal{D}\Omega$ (Fig. \ref{SDO}) \cite{Kriv} which characterizes solvable terms. %Th3.10 ?
has been proved to be undecidable by Urzyczyn \cite{Urz}. And others, simplified, type systems such as the  $\mathcal{S}$ and $\mathcal{S_r}$ systems of Van Bakel \cite{VBak} also turned out to be undecidable. All of these system are based on \emph{idempotent intersection types} ($A\wedge A = A$) which also enjoy \emph{associativity} ($(A\wedge B)\wedge C = A\wedge (B\wedge C)$) and \emph{commutativity} ($A\wedge B=B\wedge A$).

\begin{figure}
    \begin{mdframed}
        \begin{gather*}
        \inference[]{x : A \in \Gamma}{\Gamma \vdash x : A}
        \qquad
        \inference[]{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x.t : A \rightarrow B}
        \qquad
        \inference[]{\Gamma \vdash t : A \rightarrow B \quad \Gamma \vdash u : A}{\Gamma \vdash tu : B}
        \\
        \inference[]{\Gamma t : A \wedge B}{\Gamma \vdash t : A \quad \Gamma \vdash t : B}
        \qquad
        \inference[]{\Gamma \vdash t : A \quad \Gamma \vdash t : B}{\Gamma \vdash t : A \wedge B}
        \qquad
        \inference[]{}{\Gamma \vdash t : \Omega}
        \\ \text{For types } A ::= \Omega \ | \ \alpha \ | \ A \rightarrow A \ | \ A \wedge A
        \end{gather*}
    \end{mdframed}
    \caption{System $\mathcal{D}\Omega$}
    \label{SDO}
\end{figure}

Recently, researchers from the PPS laboratory in France and the University of Turin in Italy shoved that the inhabitation problem was decidable for \emph{non-idempotent} intersection types ($A\wedge A\neq A$) by exhibiting a sound and complete algorithm (Fig. \ref{INH}, p\pageref{INH}) \cite{Kes}. They used a typing system named system $\mathcal{M}$, which is the same as system $\mathcal{R}$ of R. De Carvalho \cite{DeCarvalho}.

The purpose of this work was to implement this algorithm in OCaml.

\begin{figure}[h]
    \begin{mdframed}
        \begin{gather*}
        \inference[(Var)]{}{x : [\rho] \vdash x : \rho}
        \qquad
        \inference[($\rightarrow$ I)]{\Gamma, x : A \vdash t : \rho}{\Gamma \backslash x \vdash \lambda x.t : A \rightarrow \rho}
        \\ \\
        \inference[($\rightarrow$ E)]{\Gamma_0 \vdash t : [\sigma_1, \ldots \sigma_i] \rightarrow \rho 
            & \Gamma_1 \vdash u : \sigma_1, \ldots \Gamma_i \vdash u : \sigma_i}
        {\Gamma_0 + \Gamma_1 + \cdots + \Gamma_i \vdash tu : \rho}
        \\ \\
        \text{For types } \sigma, \tau, \rho ::= \alpha \ | \ A \rightarrow \tau \qquad A ::= [\sigma_i]_{i \in I}
        \\ \text{And where $+$ refers to the \emph{multiset union}, usually denoted $\uplus$.}
        \end{gather*}
    \end{mdframed}
    \caption{The  $\mathcal{M}$-system ($\mathcal{R}$-system of D. De Carvalho \cite{DeCarvalho})}
    \label{SM}
\end{figure}

%\begin{Def}
%    A term t is \emph{solvable} iff it exists vars $x_1,\ldots,x_k$ and terms $u_1,\ldots,u_k,v_1,\ldots,v_l$ (with $k,l\geq 0$) such that $(t[\sfrac{u_1}{x_1},\ldots,\sfrac{u_k}{x_k}])v_1\ldots v_l \simeq_\beta I$
%\end{Def}

\section {Definitions}
The \lci\ and the non-idempotent intersection types used are:
\begin{align*}
	t, u, v &::= x\ |\ \lambda x.t\ |\ tu 
	& \sigma, \tau, \rho &::= \alpha \ | A \rightarrow \tau \\
	&& A &::= [\sigma_i]_{i \in I}
\end{align*}
where $\alpha$ belongs to a countable set of base types and $I$ is a finite set of indices. Non-idempotent intersection types are therefore represented by multisets ($A\wedge B$ is $[A,B]$).

All \lterms\ are defined \emph{modulo \aconv}, that is to say modulo replacing of bound vars by fresh ones: $\lambda x.t =_\alpha \lambda y.t[x\sslash y] \text{ for $y$ fresh}$

The $\beta$-reduction rule is as usual $(\lambda x.t) u ->_\beta t\{x/u\}$, defined \emph{modulo \aconv}, where $t\{x/u\}$ means replacing all the \emph{free occurrences} of $x$ in $t$ by $u$.

\begin{Ex*}
    \begin{displaymath}
        (\lambda x.(\lambda y. xy)) y 
        =_\alpha (\lambda x.(\lambda z. xz)) y
        \\->_\beta \lambda z.(xz)\{x/y\}
        =\lambda z.(x\{x/y\})(z\{x/y\})
        = \lambda z.yz
    \end{displaymath}
\end{Ex*}

In the type \sysm, represented in Fig. \ref{SM}, rules (Var) and ($\rightarrow$ I) are the same than in simply typed $\lambda$-calculus. The third rule is the interesting one, it implements the use of non-idempotent intersection types and allows the system to type even non-strongly normalizing terms when $I = \emptyset$, for example:
\begin{displaymath}
    \inference[($\rightarrow$ E)]{x:[[] \rightarrow \alpha] \vdash x : [] \rightarrow \alpha}{x : [[] \rightarrow \alpha] \vdash x((\lambda y.yy)(\lambda y.yy)) : \alpha}
\end{displaymath}
The term is typed, even if some of its subterms remain untyped. Thus a notation for these untyped subterms is needed in order to reconstruct the subject of a derivation, it is the standard notion of \emph{approximate normal form} (anf):
\begin{align*}
    a,b,c ::= \Omega\ |\ \mathcal{N} 
    && \mathcal{N} ::= \lambda x.\mathcal{N}\ |\ \mathcal{L}
    && \mathcal{L} ::= x\ |\ \mathcal{L}a
\end{align*}
And we write $\leq$ the smallest contextual order such that for all anf a, $\Omega \leq a$. Therefore, $a \leq a'$ indicates the fact that $a'$ is obtained by replacing some off the occurrences of $\Omega$ in $a$ by terms.

\begin{Ex*}
    $\lambda x.x\Omega\Omega \leq \lambda x.x\Omega y \leq \lambda x.xzy$
\end{Ex*}

\section{The algorithm}
Given an environment and a type, the algorithm constructs all the approximate normal forms inhabiting this type. This is done by exploring a vast tree of possibilities in a non-deterministic way. The algorithm (Fig. \ref{INH}) is separated in three functions, $\iT$, $\iH$ and $\iTI$:
\begin{figure}[h]
    \begin{mdframed}
        \begin{gather*}
            \inference[(ABS)]{a \in \iT(\Gamma + (x : A), \tau) & x \notin \iDom(\Gamma)}{\iLambda x.a \in \iT(\Gamma, A \rightarrow \tau)}
            \\ \\
            \inference[(HEAD)]{a \in \iH^{x:[\sigma]}_x(\Gamma, \sigma) \triangleright \tau}{a \in\iT(\Gamma + (x:[\sigma]), \tau) }
            \\ \\
            \inference[(PREFIX)]{\Gamma = \Gamma_0 + \Gamma_1 & b \in \iTI(\Gamma_0, A) & a \in \iH^{\Delta + \Gamma_0}_{cb}(\Gamma_1, \sigma) \triangleright \tau}{a \in \iH^{\Delta}_c(\Gamma, A \rightarrow \sigma) \triangleright \tau}
            \\ \\
            \inference[(FINAL)]{\sigma = \tau}{a \in \iH^{\Delta}_a(\emptyset, \sigma) \triangleright \tau}
            \qquad
            \inference[(UNION)]{(a_i \in \iT(\Gamma_i, \sigma_i))_{i \in I} & \uparrow_{i \in I}a_i}{\displaystyle \bigvee_{i \in I} a_i \in \iTI(+_{i \in I}\Gamma_i, [\sigma_i]_{i \in I}) }
        \end{gather*}
    \end{mdframed}
  \caption{The inhabitation algorithm}
  \label{INH}
\end{figure}
\begin{itemize}
\item $\iT(\Gamma, \sigma)$ contains all the anf a such that there exists a derivation $\Pi \triangleright \Gamma \vdash a : \sigma$ with $a = \mathcal{A}(\Pi)$. To build this set and then stop is the purpose of the inhabitation algorithm.
\item $\iH^\Delta_a(\Gamma, \sigma) \triangleright \tau$ contains all the anf b such that a us a head subterm of b, and such that $a \in \iT(\Delta, \sigma) \Rightarrow b \in \iT(\Gamma + \Delta, \tau)$.
\item $\iTI(\Gamma, [\sigma_i]_{i \in I})$ contains all the anf $a = \bigvee_{i\in I}a_i$ such that $ \Gamma = +_{i \in I} \Gamma_i $, $ a_i \in \iT(\Gamma_i, \sigma_i)\text{ for all }i \in I $ and $\uparrow_{i \in I}a_i$
\end{itemize}

\section{Implementation}
This implementation of the inhabitation algorithm only uses basic OCaml structures. It literally follows the algorithm and builds a list of terms being given an environment and a type. The main algorithm involves different kinds of non-determinism.

The inhabitation routine in itself  is made of numerous sub-routines which reproduce the rules of the algorithm (Fig. \ref{INH}). It recursively constructs a list of the anfs found by exploring systematically all the reachable combinations of rules.

\subsection{Types}
The implementation of the inhabitation algorithm uses basic OCaml sum types with polymorphism and recursion. 

\
\begin{lstlisting}[caption={Multisets}]
type 'a multiset =
  Empty
| Cons of 'a * 'a multiset
\end{lstlisting}

\begin{lstlisting}[caption={Intersection types and environments}]
type multisetType = 
  sType multiset
and sType = 
  Var of char
| Fleche of multisetType * sType

type environment = (char * multisetType) list
\end{lstlisting}

\begin{lstlisting}[caption={Approximate normal forms}]
type anf = 
  Omega
| N of n
and n = 
  Lambda of char * n
| L of l
and l =
  Var of char
| App of l * anf
\end{lstlisting}


\subsection{The main function}
    
\begin{lstlisting}
let rec t (env: environment) (type0 : sType) fresh =
match env, type0 with
  ([], Fleche(type1, type2)) -> 
        abs env fresh type1 type2
  | (_, Fleche(type1, type2)) -> 
        (abs env fresh type1 type2)@(head env type0 fresh)
  | (_::_, _) -> head env type0 fresh
  | (_,_) -> []
\end{lstlisting}

The calculation of $\iT(\Gamma, \sigma)$ shows a first use of non-determinism. When the environment is not empty, and the type is an arrow one, then two choices are foreseeable: ABS and HEAD.  This is solved by concatenating the results of the two calculations, thus loosing tail-recursion.

\paragraph{Abs}
\begin{displaymath}
    \inference[]{a \in \iT(\Gamma + (x : A), \tau) & x \notin \iDom(\Gamma)}{\iLambda x.a \in \iT(\Gamma, A \rightarrow \tau)}
\end{displaymath}
This rule only does a recursive call to $\iT$, but it can happens that $A = []$. In this case, $\Gamma + (x : []) = \Gamma$, and x should not been added with empty type for convenience. 

\paragraph{Head}
\begin{displaymath}
    \inference[]{a \in \iH^{x:[\sigma]}_x(\Gamma, \sigma) \triangleright \tau}{a \in\iT(\Gamma + (x:[\sigma]), \tau) }
\end{displaymath}

Here appears another kind of non-determinism: the algorithm must apply the rule for each choice of a variable and a type in the environment. For example, if $\Gamma = \{(y : [\alpha \rightarrow \alpha, \alpha]), (z : [\alpha])\}$ then three choices are available for $x:[\sigma]$: $y : [\alpha -> \alpha]$, $y : [\alpha]$ and $z : [\alpha]$.

This is done by an auxiliary function given in appendix \ref{a_extract}.

\subsection{The $\iH$ function}
\begin{lstlisting}
let rec h (env1 : environment) (env2 : environment)
    (lf : l) (type1 : sType) (type2 : sType) fresh =
  match env2, type1 with
    ([], Fleche(typeA, typeS)) -> 
        (final type1 type2 lf)
            @(prefix env1 env2 lf typeA typeS type2 fresh)
    | ([], type1) -> final type1 type2 lf
    | (_, Fleche(typeA, typeS)) -> 
        prefix env1 env2 lf typeA typeS type2 fresh
    | (_, _) -> []
\end{lstlisting}

The calculation of $\iH^\Delta_a(\Gamma, \sigma) \triangleright \tau$ uses two rules, Final and Prefix. Once again, a choice happens between multiple path, which are systematically explored by the algorithm and whose results are concatenated. 

\begin{lstlisting}[frame=single]
val prefix : environment -> environment -> l
-> multisetType -> sType -> sType -> int -> n list = <fun>
\end{lstlisting}
\begin{lstlisting}[frame=single]
val final : sType -> sType -> l -> n list = <fun>
\end{lstlisting}

\paragraph{Prefix}
\begin{displaymath}
\inference[]{\Gamma = \Gamma_0 + \Gamma_1 & b \in \iTI(\Gamma_0, A) & a \in \iH^{\Delta + \Gamma_0}_{cb}(\Gamma_1, \sigma) \triangleright \tau}{a \in \iH^{\Delta}_c(\Gamma, A \rightarrow \sigma) \triangleright \tau}
\end{displaymath}

Over again, here appears a new non-determinism, the split of $\Gamma$ in two environments. This can be done in lot of ways, mostly because the multiset types themselves can be split.

For example, the environment $\Gamma = \{(x : [\alpha \rightarrow \alpha, \alpha]), (y : [\alpha])\}$ can give:
\begin{align*}
   \Gamma_0 &= \Gamma &&and&& \Gamma_1 = \emptyset
   \\\Gamma_0 &= \{(x:[\alpha]), (y:[\alpha])\} &&and&& \Gamma_1 = \{(x:[\alpha -> \alpha])\}
   \\\Gamma_0 &= \{(y:[\alpha])\} &&and&& \Gamma_1 = \{(x : [\alpha \rightarrow \alpha, \alpha])\}
   \\\Gamma_0 &= \{(x : [\alpha \rightarrow \alpha, \alpha])\} &&and&& \Gamma_1 = \{(y:[\alpha])\}
   \\&&&\vdots&&
   \\\Gamma_0 &= \emptyset &&and&& \Gamma_1 = \Gamma
\end{align*}

Furthermore, the Union rule will need an environment to be partitioned in n parts. Thus a function has been created to list all the n-partitions of a given environment (using another one which returns all the n-partitions of a multiset). It does a massive usage of List.map to iterate the split for each cases. Its complexity lie in the structure of environments which are lists of multisets which all needs to be divided. It can be found in appendix \ref{a_part}. This algorithm will be detailed in the next section (\ref{ss_ti}).

\subsection{The $\iTI$ (Union) function}
\label{ss_ti}

\begin{lstlisting}
val union : env -> multisetType -> int -> anf = <fun>
\end{lstlisting}

\begin{displaymath}
    \inference[]{(a_i \in \iT(\Gamma_i, \sigma_i))_{i \in I} & \uparrow_{i \in I}a_i}{ \bigvee_{i \in I} a_i \in \iTI(+_{i \in I}\Gamma_i, [\sigma_i]_{i \in I}) }
\end{displaymath}

Union tries to find the least upper bound of the anfs generated by $\iT(\Gamma, [\sigma_i]_{i \in I})$ for each partition of $\Gamma$. Normally, the algorithm should check that such a bound exists ($\uparrow_{i \in I}a_i$), but in fact it's existence it has been proven \cite{Kes}.

To partition the environment, the same sub-routine than for Prefix is used, printed in appendix \ref{a_part}. This recursive algorithm has a very simple mechanism:
Given a set $E$ and a integer $n$ For each element $e\in E$ it creates $n$ $n$-tuples with the $n$ distinct positions choices for $e$. Then it merges this list with the result of the same operation other the tail.

For example, given the set $\{a,b,c\}$ and the integer 3, the computation will be:
\begin{align*}
    &\ [\ []\ ,\ []\ ,\ []\ ]\ &
    \\&\ [\ [\ [c]\ ,\ []\ ,\ []\ ]\ ,\ [\ []\ ,\ [c]\ ,\ []\ ]\ ,\ [\ []\ ,\ []\ ,\ [c]\ ]\ ]\ &
    \\&\ [\ [\ [cb]\ ,\ []\ ,\ []\ ]\ ,\ [\ [c]\ ,\ [b]\ ,\ []\ ]\ ,\ [\ [c]\ ,\ []\ ,\ [b]\ ]\ ,
    \ [\ [b]\ ,\ [c]\ ,\ []\ ]\ ,&
    \\&\ \ \ [\ []\ ,\ [cb]\ ,\ []\ ]\ ,\ [\ []\ ,\ [c]\ ,\ [b]\ ]\ ,
    \ [\ [b]\ ,\ []\ ,\ [c]\ ]\ ,\ [\ []\ ,\ [b]\ ,\ [c]\ ]\ ,\ [\ []\ ,\ []\ ,\ [cb]\ ]\  ]&
    \\&\ldots&
\end{align*}

\subsection{Execution examples}
Quelques exemples détaillés d'éxecution, notamment avec Omega
\section{Termination, soundness and completeness}
The proofs of these properties are in the original article \cite{Kes}, we will just explain some aspects of these proofs.

\begin{Th*}[Termination]
    The inhabitation algorithm terminates.
\end{Th*}

\begin{proof}
    To prove the termination of the algorithm, it is necessary to show that the predicates $\iT(\Gamma, \sigma)$, $\iH^\Delta_a(\Gamma, \sigma) \triangleright \tau$ and $\iTI(\Gamma, [\sigma_i]_{i \in I})$ are well defined finite sets. This is proved by induction of their arguments on the following measure:
    \begin{align*}
    \#(\alpha) &= 1 & \#([\sigma_i]_{i\in I}) &= \textstyle \sum_{i\in I}\#(\sigma_i) +1
    \\ \#(A -> \rho) &= \#(A) + \#(\rho) + 1 & \#(\Gamma) &= \textstyle \sum_{x\in dom(\Gamma)} \#(\Gamma(x))
    \end{align*}
\end{proof}

 To prove soundness and completeness it necessary to link runs of the algorithm with typings of approximate normal forms in \sysm:
 \begin{Lem*}
 $a \in \iT(\Gamma, \sigma) <=> \exists\Pi\triangleright\Gamma\vdash a : \sigma \text{ such that } a = \mathcal{A}(\Pi)$
\end{Lem*}

\begin{Th*}[Soundness]
    $a \in \iT(\Gamma, \sigma) => \forall t, (a \leq t => \Gamma \vdash t : \sigma)$
\end{Th*}

\begin{Th*}[Completeness]
    If $\Pi \triangleright \Gamma \vdash t : \sigma$ then there exists $\Pi ' \triangleright \Gamma \vdash t' : \sigma$ such that $t'$ is in \emph{$\Pi$'-normal form} and the minimal approximant of $t'$ is in $\iT(\Gamma, \sigma)$
\end{Th*}
 


\section{Conclusion}
Just a proof of concept, some optimisations may be needed for use with complex types.
Opening toward more complex lambda-calculus: with pair and projections, and more widely pattern calculi. (ref)


\newpage
\bibliographystyle{plain}
\bibliography{main.bib}

\newpage
\appendix
\section{Extracting a var from an environment}
\label{a_extract}
\begin{lstlisting}
(* Given a multiset, returns a list of couples
(var extracted, rest of the multiset) (tail-recursive) *)
let extractMS l =
  let rec aux acc acc2 = function
    Empty -> acc2
    | Cons(h, t) -> 
  (aux (Cons(h, acc)) ((h, concat acc t)::acc2) t)
in aux Empty [] l
\end{lstlisting}


\begin{lstlisting}
(* Returns all the extractions of a var and a type 
from a given  environment *)
let envExtracts (env : environment) = 
  let rec aux acc acc2 = function
    [] -> acc2
    | (x, types)::t -> 
        (aux ((x, types)::acc) ((List.map (fun ex -> 
    let (e, tail) = ex in 
    let elt = Cons(e, Empty) in 
    match tail with
      Empty -> ((x, elt), t@acc)
      | _ -> 
((x, elt), (x, tail)::t@acc)) (extractMS types))@acc2) t) 

  in aux [] [] env
\end{lstlisting}

\newpage
\section{Partitions of an environment}
\label {a_part}
\begin{lstlisting}
let rec splitsN ms n = 
  (* Add an element to a split in every possible way (tr) *)
  let rec add decoupe acc acc2 x = match decoupe with 
    [] -> acc2
    | h::tl -> 
        add tl (h::acc) ((acc@(Cons(x, h)::tl))::acc2) x
  in
   
  match ms with
    Empty -> [initMS n] (* [[ [];[];[];...;[] ]] *)
    | Cons(h, tl) -> let reste = (splitsN tl n) in
       List.concat (
         List.map (fun d ->  (add d [] [] h)) reste
       )
\end{lstlisting}
\begin{lstlisting}
let rec envSplitsN n = function
  [] -> [initList n]
  | (x, tys)::tl -> let decoupes = splitsN tys n 
                       and reste = envSplitsN n tl in
    let decoupesX = 
      (* Re-establishing 
          the (x : multiset) list structure *)
      List.map (fun paquets -> 
        List.map (fun paquet -> 
            (x, paquet)
        ) paquets
      ) decoupes in
            
    List.concat (
      (* Adding to the rest all the different
          choices for each var *)
      List.map (fun envs -> 
        (* For each choice of x 
            we divide again the environments *)
        List.map (fun decoupeX -> 
          List.map2 (fun x env -> 
            x::env
          ) decoupeX envs
        ) decoupesX
      ) reste
    )
\end{lstlisting}

\newpage
\section{The inhabitation algorithm}
Code définitif de l'algorithme
\end{document}